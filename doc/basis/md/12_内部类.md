# 内部类
一个类中的另一个类就是内部类；
## 为什么使用内部类？
类：描述具体的事物；

- 如果一个类只提供给一个类使用，其他类都不能访问，这个时候使用内部类；
- 继承，如果一个类已经有了一个父类，但是还想直接使用另一个类中的内容，内部类；

## 作用
提高了安全性，只提供给外部类使用，其他类不能访问；
		
## 内部类类别
- 成员内部类
- 静态内部类
- 局部内部类
- 匿名内部类

## 内部类的全称
Outer$Inner;外部类名称$内部类名称
## 成员内部类
可以访问外部类的属性和方法:隐式的this指向；Outer.this

### 创建内部类对象
1. 创建外部类对象那个：属于外部类对象
```
Outer out = new Outer();
```
2. 通过Outer对象创建内部类对象
```	
Outer.Inner inner = out.new Inner();
```	 	
### 不能拥有静态内容
- 他相当于外部类的一个普通方法，他是属于对象的；
- static随着类的加载而出现，这个时候还没有对象；
- 成员内部类不能拥有静态内容；
		
## 静态内部类：Outer$Inner
- 被static修饰的内部类就是静态内部类； 
- 只能访问静态的内容，通过隐式的Outer	访问外部类的静态num:Outer.num;
- 不能访问外部类的属性和方法；	
- 可以拥有静态的内容；
### 创建对象
因为是静态的，不需要外部类对象，因此直接创建
```
Outer.Inner innner = new Outer.Inner();//创建了一个外部类的内部类对象；
```
### 如何调用内部类的静态方法？
```
Outer.Inner.show();//show是一个静态方法；
```
### 为什么static不能和this一起使用？
static随着类的加载而出现，这个时候还没有对象，所以不能和this一起使用；	

## 局部内部类
- 可以访问外部类的属性和方法只在当前方法有效；
- 局部内部类访问局部变量，必须使用final修饰；“：如果是局部变量，会随着方法的消失而消失，然而这个时候对象还存在。访问了一个不存在的数据，所以报错.加上final修饰成为常量，在常量池中，没有消失，因此可以访问；

### 成员内部类和静态内部类的区别？
- 拥有内容
  - 成员：只能拥有非静态内容
  - 静态：可以拥有静态内容，也可以拥有非静态
- 方法调用
  - 成员：
	1. 先创建外部类对象：Outer out = new Outer();
	2. 创建内部类对象	Outer.Inner in = out.new inner();	
  - 静态：
	1. 不需要外部类对象：
			Outer.Inner in = new Outer.Inner();
	2. 调用静态方法：
			Outer.Inner.show();
- 访问内容
  - 成员：
	可以访问外部类的属性和方法
  - 静态：
	只能访问外部类的静态内容；

## 局部内部类
也可以访问外部类的属性和方法，以及静态内容
### 局限性
- 在访问局部 变量时，必须final修饰
- 只在当前方法有效（作用域）
		
## 匿名内部类
- 匿名对象：
没有名字的对象；
- 使用前提：
只使用一次；

- 匿名内部类：
没有名字的内部类；
- 前提：
	必须有一个接口或者抽象类；
```
new InterDemo(){
	public void method(){
		
	}
};
```
- new：在堆内存中开辟空间，所以匿名内部类它也是一个对象
- 对象：子类对象：--->不知道子类名字的对象；
**注意：不会在匿名内部类中定义独有的函数；**
- 优点:
不必定义实现类，就可以使用接口中的内容
- 缺点:
只能使用一次；	
```
provide(USB usb)
Button btn.setOnclickLisener(new Oclick(){
	public void click(View v){//btn;
		
	}
});
```
### 声明步骤
1. 不知道儿子叫什么，找父亲
2. 需要证明他们的关系，重写接口中的方法
3. 调用方法：因为本身就是一个不知道名字的子类对象，所以可以直接调用方法
```
new InterDemo(){
	public void method();
}.method();
```			


# final、多态、抽象类
## 回顾
### static关键字
特点
- 共享给所有的对象
- 优先于对象存在
- 随着类的加载而出现

### 静态变量和成员变量的区别？
- 成员属于对象
- 静态属于类
- 成员在堆内存
- 静态在方法区
- 成员随着对象的创建而出现，随着对象的消失而消失
- 静态随着类的加载出现，随着类的消失而消失
- 成员：实例变量
- 静态：全局变量（类变量）
	
## 封装
### 作用
- 保护的作用
- 提高了代码的复用性
- 便于维护程序
### 常用的封装
- private属性
- 设置set,get函数
	
## 成员变量和局部变量区别？
- 位置
  - 成员：类里面，方法外面
  - 局部：方法里面，代码块里面
- 初始化
  - 成员可以先不初始化，默认值
  - 局部：必须初始化
- 声明周期
  - 成员：随着对象的创建而产生，随着对象的毁灭而毁灭
  - 局部：随着方法的执行而出现，随着方法的消失而消失
- 作用域
  - 成员：整个类
  - 局部：作用域代码块方法里面
- 内存位置
  - 成员：堆内存
  - 局部：栈内存

## 继承
### 作用
简化代码，提高了复用性
### 那些内容不能继承
构造方法，私有的内容

## final关键字
- 最终的；
- 可以修饰变量：成为一个常量，不能修改值；
- 可以修饰方法:不能被重写：这个方法不允许改动的；
- 可以修饰类：不能被继承
	
## 多态
- 多种形态（多种表现形式）
- 编译时多态：计划	重载
- 运行时多态：实施	重写
	
### 对象的多态性
	
- 子承父业：
有一天，父亲发生了意外，不能登台演出。台下有很多老戏迷在等待，为了不让观众失望，决定让其儿子替代父亲演出；
- 向上转型
```
Fu f = new Zi();//父类引用指向子类对象
```
- 向下转型
```
Zi z = (Zi)f;想要向下转型，必须先向上转型。打回原形
```
	
**a  instanceof  type:
如果a是type的类型，返回true， 否则返回false；**
	
- 多态的前提条件
1. 必须有继承或者实现的关系
2. 重写
3. 父类引用指向子类对象Fu f = new Zi();
	
## 抽象类abstract；
### 抽象方法没有方法体
如果一个类中有抽象方法，这个类一定是抽象类

### 如何使用抽象类？
- 子类继承，实现抽象方法；
- 如果子类没有实现方法，则子类还是抽象类；

**抽象类不可以实例化（创建对象）**

### 有没有构造函数？
- 有构造函数。提供给子类；
- 之所以不能实例化，是因为关键字abstract；

### 哪些关键字不能和abstract一起使用？
- final：	修饰的类不能被继承，方法不能被重写
- static:	类名.调用		不需要对象，可以直接调用抽象方法；
- private:私有的，不能被继承，抽象方法无法使用；
	

### 抽象类和普通类有哪些区别？
1. 抽象类不能被实例化;普通类可以实例化
2. 抽象类可以有抽象方法，也可以有普通方法;普通类不能有抽象方法
3. 抽象类必须被继承才能使用，必须作为父类存在;普通类可以继承，也可以不被继承
		
//代码不是看出来的，是写出来的，思想不是想出来的，是敲出来的

### 匿名对象
这个对象确定了只使用一次；
		
- Object：
它是所有类的父类
	
**自定义的类如果没有显示定义父类，则隐式的继承了Object**

### equals
在父类（Object,String重写了）中，比较的是两个对象的地址是否相同，如果相同返回true，否则返回false；
	
### 重写equals
因为父类的equals比较的是地址，但是一般情况下希望比较的是内容，因此需要重写


```java
zhangsan.equals(lisi);
public boolean equals(Object obj){//obj = new Studnet();
	//需要判断obj是不是一个Student对象；
	if(obj instanceof Student){
		Student s = (Student) obj;
		if(this.age == s.age && this.name.equals(s.name)){
			return true;
		}
	}
	return false;
```
### 代码解析
1. this：代表了当前对象（谁调用了this所在的函数，谁就是那个对象）
2. zhangsan.equals(lisi);
equals是this所在的函数，被zhangsan调用了，所以this指向的是zhangsan;
3. equals(Object obj):	lisi
obj = list = new Student();----->Object obj = new Student();儿子代替父亲；向上
为了防止发生其他的儿子进来，和Student不匹配，因此验证一下；
如果返回true
	this.age ---->zhangsan的年龄
	s.age -------->obj--->lisi;

### toString
- 默认打印的是对象的内存地址；
- 返回的是个字符串；
	
### 重写toString
开发过程中，更多时候，需要看的是对象的内容，而非地址，因此需要重写toString函数
	
### getClass().getName():
用来获取字节码文件的名称；

### hashcode();
默认返回的是地址；

### 重写
计算的是对象的内容返回的一个id标识；
为了减轻equals的负担。
如果id不一样，直接存储；否则id一样，为了确保数据的准确性，调用equals去比较内容，如果返回true，不存储，否则存储；


	
